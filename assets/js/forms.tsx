import React, { StrictMode, useState } from "react";
import { createRoot } from "react-dom/client";

import { config } from "./config";
import { workflows } from "./workflows";
import GenerateFrom from "./forms/Index";

export class FormGenerator {
  public data: any;
  public schema: any;
  public uischema: any;
  public variables: any;
  public resp: any;
  public view: string;
  public $form: HTMLElement;
  public hasFooter: boolean;

  private container: HTMLElement;
  private errors: any[];

  protected constructor(
    public project_id: string,
    public job_to_run: string,
    public debug: boolean = false
  ) {}

  initForm($el: HTMLElement, form: { schema: any; uischema: any; data: any }) {
    if (!form) return;
    if ($el) this.generateForm($el, form?.schema, form?.uischema, form?.data);
  }

  isReady() {
    return workflows.isReady(this.project_id);
  }

  isValid() {
    return !!this.errors?.length;
  }

  getVariables() {
    // If the variables were already captured, we use them as-is (no need to go search for them)
    if (this.variables) return this.variables;

    // Alternatively, collect form controls that have a "name" attribute (eg: capture raw input vars)
    const inputs = Array.from(this.$el.querySelectorAll("[name]"));
    const values = inputs.reduce(
      (agg: any, inp: HTMLInputElement) => ({ ...agg, [inp.name]: inp.value }),
      {}
    );

    console.debug("captured", values);
    return values;
  }

  setVariables(data: any) {
    this.variables = Object.assign({}, data);
    this.dispatch(new CustomEvent("form:data", { detail: data }));
  }

  /**
   * Generates a form given the JSON Forms schema and uischema
   * @param $el The element to bind the form generation to
   */
  async generateForm($el: HTMLElement, schema: any, uischema: any, data: any) {
    // Bind the form data to this controller
    this.schema = schema;
    this.uischema = uischema;
    this.data = data;

    // Create a child container element to work with (and remove old one if exists)
    const contents = document.createElement("div");
    if (this.container) this.container.innerHTML = ""; // Clear old contents
    this.container = $el;
    this.container.appendChild(contents);

    // Bind the react component to the newly created container and capture data
    const onData = (data: any, errors: any[]) => {
      this.setVariables(data);
      this.errors = errors;
    };
    const options = { schema, uischema, data, onData };
    const root = createRoot(contents);
    this.dispatch(new CustomEvent("form.create", { detail: options }));
    root.render(
      <StrictMode>
        <GenerateFrom {...options} />
      </StrictMode>
    );

    // Detect if we have form control buttons to submit.
    // If no submit button found, attach a generic submit button
    const buttons = Array.from($el.querySelectorAll('[type="submit"]'));
    const noCtrls = !buttons || !buttons.length;
    this.hasFooter = noCtrls;
    if (noCtrls) {
      //this.dispatch(new CustomEvent("form:ctrls", { detail: noCtrls }));
    }

    // Trigger an event to inform external components that data changed
    const detail = { schema, uischema, data };
    this.dispatch(new CustomEvent("form:init", { detail }));
  }

  dispatch(event: CustomEvent) {
    //const target = this.$form || window;
    console.debug(event.type, [this.$form?.id], event.detail, event);
    window.dispatchEvent(event);
  }

  /**
   * Trigger a new pipeline using the captured inputs
   * @param $event The submit event generated by the target form element
   * @returns False is returned, to cancel the event from bubling upwards
   */
  async newPipeline($event: Event = null) {
    if ($event) {
      $event.stopPropagation();
      $event.preventDefault();
    }

    // Collect the variables to attach to the request
    let variables = { ...this.getVariables() };
    if (!variables["JOB_TO_RUN"] && this.job_to_run) {
      variables["JOB_TO_RUN"] = this.job_to_run;
    }
    Object.keys(variables).forEach((key) => {
      variables[key] = `${variables[key]}`;
    });

    // Build a request payload to trigger a pipeline
    const ref = workflows.getRef();
    const trigger = await workflows.getTrigger(this.project_id);
    const token = trigger?.token;
    const method = "POST";
    const action = `${config.apiURL}/api/v4/projects/${this.project_id}/trigger/pipeline`;
    const headers = { "Content-Type": "application/json" };
    const body = JSON.stringify({
      ref,
      token,
      variables,
    });

    // Send the request to start a new pipeline and wait for a response
    console.debug("form.submit", variables, [method, action]);
    const resp = await fetch(action, { method, headers, body })
      .then((res) => workflows.jsonResponse(res))
      .catch((err) => console.error(err));
    console.debug("form.resp", resp);

    // If the request was successfull, we redirect to the pipeline viewer page
    if (resp?.id) {
      window.location.href = `${config.baseURL}/pipelines?id=${resp.id}`;
      return false;
    }

    // Save the response object
    this.resp = resp;

    return false;
  }
}
